#include <fstream>
#include <math.h>
#include <stdlib.h>

#include "../../../includes/InputSet/TopologyFileSpace/topologyfile.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyatompair.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologybondtype.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyangletype.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologydihedraltype.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyassembly.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyatom.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologybond.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyangle.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologydihedral.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyresidue.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologybond.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyangle.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologydihedral.hpp"
#include "../../../includes/InputSet/TopologyFileSpace/topologyfileprocessingexception.hpp"
#include "../../../includes/utils.hpp"

using TopologyFileSpace::TopologyFile;

//////////////////////////////////////////////////////////
//                       CONSTRUCTOR                    //
//////////////////////////////////////////////////////////
TopologyFile::TopologyFile()
{
    title_ = "Generated by GMML";
    path_ = "";
    number_of_atoms_ = gmml::iNotSet;
    number_of_types_ = gmml::iNotSet;
    number_of_bonds_including_hydrogen_ = gmml::iNotSet;
    number_of_angles_including_hydrogen_ = gmml::iNotSet;
    number_of_dihedrals_including_hydrogen_ = gmml::iNotSet;
    number_of_bonds_excluding_hydrogen_ = gmml::iNotSet;
    number_of_angles_excluding_hydrogen_ = gmml::iNotSet;
    number_of_dihedrals_excluding_hydrogen_ = gmml::iNotSet;
    number_of_hydrogen_parameters_ = gmml::iNotSet;
    number_of_parameters_ = gmml::iNotSet;
    number_of_excluded_atoms_ = gmml::iNotSet;
    number_of_residues_ = gmml::iNotSet;
    total_number_of_bonds_ = gmml::iNotSet;
    total_number_of_angles_ = gmml::iNotSet;
    total_number_of_dihedrals_ = gmml::iNotSet;
    number_of_bond_types_ = gmml::iNotSet;
    number_of_angle_types_ = gmml::iNotSet;
    number_of_dihedral_types_ = gmml::iNotSet;
    number_of_atom_types_in_parameter_file_ = gmml::iNotSet;
    number_of_distinct_hydrogen_bonds_ = gmml::iNotSet;
    perturbation_option_ = gmml::iNotSet;
    number_of_bonds_perturbed_ = gmml::iNotSet;
    number_of_angles_perturbed_ = gmml::iNotSet;
    number_of_dihedrals_perturbed_ = gmml::iNotSet;
    number_of_bonds_group_perturbed_ = gmml::iNotSet;
    number_of_angles_group_perturbed_ = gmml::iNotSet;
    number_of_dihedrals_group_perturbed_ = gmml::iNotSet;
    standard_periodic_box_option_ = gmml::iNotSet;
    number_of_atoms_in_largest_residue_ = gmml::iNotSet;
    cap_option_ = gmml::iNotSet;
    number_of_extra_points_ = gmml::iNotSet;
    number_of_beads_ = gmml::iNotSet;
    pairs_ = TopologyAtomPairMap();
    bond_types_ = TopologyBondTypeMap();
    angle_types_ = TopologyAngleTypeMap();
    dihedral_types_ = TopologyDihedralTypeMap();
    assembly_ = new TopologyFileSpace::TopologyAssembly();
    radius_set_ = RadiusSet();
    bonds_ = TopologyBondMap();
    angles_ = TopologyAngleMap();
    dihedrals_ = TopologyDihedralMap();
}

TopologyFile::TopologyFile(const std::string &top_file)
{
    path_ = top_file;
    std::ifstream in_file;
    if(std::ifstream(top_file.c_str()))
        in_file.open(top_file.c_str());
    else
    {
        throw TopologyFileProcessingException(__LINE__, "Topology file not found");
    }
    Read(in_file);
    in_file.close();            /// Close the parameter files
}

//////////////////////////////////////////////////////////
//                         ACCESSOR                     //
//////////////////////////////////////////////////////////
std::string TopologyFile::GetPath()
{
    return path_;
}
std::string TopologyFile::GetTitle()
{
    return title_;
}
int TopologyFile::GetNumberOfAtoms()
{
    return number_of_atoms_;
}
int TopologyFile::GetNumberOfTypes()
{
    return number_of_types_;
}
int TopologyFile::GetNumberOfBondsIncludingHydrogen()
{
    return number_of_bonds_including_hydrogen_;
}
int TopologyFile::GetNumberOfAnglesIncludingHydrogen()
{
    return number_of_angles_including_hydrogen_;
}
int TopologyFile::GetNumberOfDihedralsIncludingHydrogen()
{
    return number_of_dihedrals_including_hydrogen_;
}
int TopologyFile::GetNumberOfBondsExcludingHydrogen()
{
    return number_of_bonds_excluding_hydrogen_;
}
int TopologyFile::GetNumberOfAnglesExcludingHydrogen()
{
    return number_of_angles_excluding_hydrogen_;
}
int TopologyFile::GetNumberOfDihedralsExcludingHydrogen()
{
    return number_of_dihedrals_excluding_hydrogen_;
}
int TopologyFile::GetNumberOfHydrogenParameters()
{
    return number_of_hydrogen_parameters_;
}
int TopologyFile::GetNumberOfParameters()
{
    return number_of_parameters_;
}
int TopologyFile::GetNumberOfExcludedAtoms()
{
    return number_of_excluded_atoms_;
}
int TopologyFile::GetNumberOfResidues()
{
    return number_of_residues_;
}
int TopologyFile::GetTotalNumberOfBonds()
{
    return total_number_of_bonds_;
}
int TopologyFile::GetTotalNumberOfAngles()
{
    return total_number_of_angles_;
}
int TopologyFile::GetTotalNumberOfDihedrals()
{
    return total_number_of_dihedrals_;
}
int TopologyFile::GetNumberOfBondTypes()
{
    return number_of_bond_types_;
}
int TopologyFile::GetNumberOfAnglesTypes()
{
    return number_of_angle_types_;
}
int TopologyFile::GetNumberOfDihedralTypes()
{
    return number_of_dihedral_types_;
}
int TopologyFile::GetNumberOfAtomTypesInParameterFile()
{
    return number_of_atom_types_in_parameter_file_;
}
int TopologyFile::GetNumberOfDistinctHydrogenBonds()
{
    return number_of_distinct_hydrogen_bonds_;
}
int TopologyFile::GetPerturbationOption()
{
    return perturbation_option_;
}
int TopologyFile::GetNumberOfBondsPerturbed()
{
    return number_of_bonds_perturbed_;
}
int TopologyFile::GetNumberOfAnglesPerturbed()
{
    return number_of_angles_perturbed_;
}
int TopologyFile::GetNumberOfDihedralsPerturbed()
{
    return number_of_dihedrals_perturbed_;
}
int TopologyFile::GetNumberOfBondsGroupPerturbed()
{
    return number_of_bonds_group_perturbed_;
}
int TopologyFile::GetNumberOfAnglesGroupPerturbed()
{
    return number_of_angles_group_perturbed_;
}
int TopologyFile::GetNumberOfDihedralsGroupPerturbed()
{
    return number_of_dihedrals_group_perturbed_;
}
int TopologyFile::GetStandardPeriodicBoxOption()
{
    return standard_periodic_box_option_;
}
int TopologyFile::GetNumberOfAtomsInLargestResidue()
{
    return number_of_atoms_in_largest_residue_;
}
int TopologyFile::GetCapOption()
{
    return cap_option_;
}
int TopologyFile::GetNumberOfExtraPoints()
{
    return number_of_extra_points_;
}
int TopologyFile::GetNumberOfBeads()
{
    return number_of_beads_;
}
TopologyFile::TopologyAtomPairMap TopologyFile::GetPairs()
{
    return pairs_;
}
TopologyFile::TopologyBondTypeMap TopologyFile::GetBondTypes()
{
    return bond_types_;
}
TopologyFile::TopologyAngleTypeMap TopologyFile::GetAngleTypes()
{
    return angle_types_;
}
TopologyFile::TopologyDihedralTypeMap TopologyFile::GetDihedralTypes()
{
    return dihedral_types_;
}
TopologyFileSpace::TopologyAssembly* TopologyFile::GetAssembly()
{
    return assembly_;
}

TopologyFile::RadiusSet TopologyFile::GetRadiusSet()
{
    return radius_set_;
}
TopologyFile::TopologyBondMap TopologyFile::GetBonds()
{
    return bonds_;
}
TopologyFile::TopologyAngleMap TopologyFile::GetAngles()
{
    return angles_;
}
TopologyFile::TopologyDihedralMap TopologyFile::GetDihedrals()
{
    return dihedrals_;
}
TopologyFile::TopologyAtomTypeIndexMap TopologyFile::GetAtomTypeIndexMap()
{
    TopologyAtomTypeIndexMap atom_type_index_map;
    int index = 0;
    int count = 1;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            if(atom_type_index_map[atom->GetType()] == 0)
            {
                atom_type_index_map[atom->GetType()] = count;
                count++;
            }
        }
    }
    return atom_type_index_map;
}
TopologyFileSpace::TopologyBondType* TopologyFile::GetBondTypeByIndex(int index)
{
    for(TopologyBondTypeMap::iterator it = bond_types_.begin(); it != bond_types_.end(); it++)
    {
        TopologyFileSpace::TopologyBondType* bond_type = (*it).second;
        if(bond_type->GetIndex() == index)
            return bond_type;
    }
    return NULL;
}
TopologyFileSpace::TopologyAngleType* TopologyFile::GetAngleTypeByIndex(int index)
{
    for(TopologyAngleTypeMap::iterator it = angle_types_.begin(); it != angle_types_.end(); it++)
    {
        TopologyFileSpace::TopologyAngleType* angle_type = (*it).second;
        if(angle_type->GetIndex() == index)
            return angle_type;
    }
    return NULL;
}
TopologyFileSpace::TopologyDihedralType* TopologyFile::GetDihedralTypeByIndex(int index)
{
    for(TopologyDihedralTypeMap::iterator it = dihedral_types_.begin(); it != dihedral_types_.end(); it++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = (*it).second;
        if(dihedral_type->GetIndex() == index)
        {
            return dihedral_type;
        }
    }
    return NULL;
}
TopologyFileSpace::TopologyAtomPair* TopologyFile::GetAtomPairByIndex(int index)
{
    for(TopologyAtomPairMap::iterator it = pairs_.begin(); it != pairs_.end(); it++)
    {
        TopologyFileSpace::TopologyAtomPair* atom_pair = (*it).second;
        if(atom_pair->GetIndex() == index)
            return atom_pair;
    }
    return NULL;
}

//////////////////////////////////////////////////////////
//                          MUTATOR                     //
//////////////////////////////////////////////////////////
void TopologyFile::SetPath(std::string path)
{
    path_ = path;
}
void TopologyFile::SetTitle(const std::string title)
{
    title_ = title;
}
void TopologyFile::SetNumberOfAtoms(int number_of_atoms)
{
    number_of_atoms_ = number_of_atoms;
}
void TopologyFile::SetNumberOfTypes(int number_of_types)
{
    number_of_types_ = number_of_types;
}
void TopologyFile::SetNumberOfBondsIncludingHydrogen(int number_of_bonds_including_hydrogen)
{
    number_of_bonds_including_hydrogen_ = number_of_bonds_including_hydrogen;
}
void TopologyFile::SetNumberOfAnglesIncludingHydrogen(int number_of_angles_including_hydrogen)
{
    number_of_angles_including_hydrogen_ = number_of_angles_including_hydrogen;
}
void TopologyFile::SetNumberOfDihedralsIncludingHydrogen(int number_of_dihedrals_including_hydrogen)
{
    number_of_dihedrals_including_hydrogen_ = number_of_dihedrals_including_hydrogen;
}
void TopologyFile::SetNumberOfBondsExcludingHydrogen(int number_of_bonds_excluding_hydrogen)
{
    number_of_bonds_excluding_hydrogen_ = number_of_bonds_excluding_hydrogen;
}
void TopologyFile::SetNumberOfAnglesExcludingHydrogen(int number_of_angles_excluding_hydrogen)
{
    number_of_angles_excluding_hydrogen_ = number_of_angles_excluding_hydrogen;
}
void TopologyFile::SetNumberOfDihedralsExcludingHydrogen(int number_of_dihedrals_excluding_hydrogen)
{
    number_of_dihedrals_excluding_hydrogen_ = number_of_dihedrals_excluding_hydrogen;
}
void TopologyFile::SetNumberOfHydrogenParameters(int number_of_hydrogen_parameters)
{
    number_of_hydrogen_parameters_ = number_of_hydrogen_parameters;
}
void TopologyFile::SetNumberOfParameters(int number_of_parameters)
{
    number_of_parameters_ = number_of_parameters;
}
void TopologyFile::SetNumberOfExcludedAtoms(int number_of_excluded_atoms)
{
    number_of_excluded_atoms_ = number_of_excluded_atoms;
}
void TopologyFile::SetNumberOfResidues(int number_of_residues)
{
    number_of_residues_ = number_of_residues;
}
void TopologyFile::SetTotalNumberOfBonds(int total_number_of_bonds)
{
    total_number_of_bonds_ = total_number_of_bonds;
}
void TopologyFile::SetTotalNumberOfAngles(int total_number_of_angles)
{
    total_number_of_angles_ = total_number_of_angles;
}
void TopologyFile::SetTotalNumberOfDihedrals(int total_number_of_dihedrals)
{
    total_number_of_dihedrals_ = total_number_of_dihedrals;
}
void TopologyFile::SetNumberOfBondTypes(int number_of_bond_types)
{
    number_of_bond_types_ = number_of_bond_types;
}
void TopologyFile::SetNumberOfAngleTypes(int number_of_angle_types)
{
    number_of_angle_types_ = number_of_angle_types;
}
void TopologyFile::SetNumberOfDihedralTypes(int number_of_dihedral_types)
{
    number_of_dihedral_types_ = number_of_dihedral_types;
}
void TopologyFile::SetNumberOfAtomTypesInParameterFile(int number_of_atom_types_in_parameter_file)
{
    number_of_atom_types_in_parameter_file_ = number_of_atom_types_in_parameter_file;
}
void TopologyFile::SetNumberOfDistinctHydrogenBonds(int number_of_distinct_hydrogen_bonds)
{
    number_of_distinct_hydrogen_bonds_ = number_of_distinct_hydrogen_bonds;
}
void TopologyFile::SetPerturbationOption(int perturbation_option)
{
    perturbation_option_ = perturbation_option;
}
void TopologyFile::SetNumberOfBondsPerturbed(int number_of_bonds_perturbed)
{
    number_of_bonds_perturbed_ = number_of_bonds_perturbed;
}
void TopologyFile::SetNumberOfAnglesPerturbed(int number_of_angles_perturbed)
{
    number_of_angles_perturbed_ = number_of_angles_perturbed;
}
void TopologyFile::SetNumberOfDihedralsPerturbed(int number_of_dihedrals_perturbed)
{
    number_of_dihedrals_perturbed_ = number_of_dihedrals_perturbed;
}
void TopologyFile::SetNumberOfBondsGroupPerturbed(int number_of_bonds_group_perturbed)
{
    number_of_bonds_group_perturbed_ = number_of_bonds_group_perturbed;
}
void TopologyFile::SetNumberOfAnglesGroupPerturbed(int number_of_angles_group_perturbed)
{
    number_of_angles_group_perturbed_ = number_of_angles_group_perturbed;
}
void TopologyFile::SetNumberOfDihedralsGroupPerturbed(int number_of_dihedrals_group_perturbed)
{
    number_of_dihedrals_group_perturbed_ = number_of_dihedrals_group_perturbed;
}
void TopologyFile::SetStandardPeriodicBoxOption(int standard_periodic_box_option)
{
    standard_periodic_box_option_ = standard_periodic_box_option;
}
void TopologyFile::SetNumberOfAtomsInLargestResidue(int number_of_atoms_in_largest_residue)
{
    number_of_atoms_in_largest_residue_ = number_of_atoms_in_largest_residue;
}
void TopologyFile::SetCapOption(int cap_option)
{
    cap_option_ = cap_option;
}
void TopologyFile::SetNumberOfExtraPoints(int number_of_extra_points)
{
    number_of_extra_points_ = number_of_extra_points;
}
void TopologyFile::SetNumberOfBeads(int number_of_beads)
{
    number_of_beads_ = number_of_beads;
}
void TopologyFile::SetAssembly(TopologyFileSpace::TopologyAssembly *assembly)
{
    assembly_ = assembly;
}

void TopologyFile::SetRadiusSet(RadiusSet radius_set)
{
    radius_set_.clear();
    for(RadiusSet::iterator it = radius_set.begin(); it != radius_set.end(); it++)
    {
        radius_set_.push_back(*it);
    }
}
void TopologyFile::SetBonds(TopologyBondMap bonds)
{
    bonds_.clear();
    for(TopologyBondMap::iterator it = bonds.begin(); it != bonds.end(); it++)
    {
        std::string atom_bond = (*it).first;
        TopologyBond* bond = (*it).second;
        bonds_[atom_bond] = bond;
    }
}
void TopologyFile::AddBond(TopologyBond *bond)
{
    std::vector<std::string> bonds = bond->GetBonds();
    std::vector<std::string> residue_names = bond->GetResidueNames();
    TopologyFileSpace::TopologyBondType* bond_type = bond->GetBondType();
    std::stringstream ss;
    ss << residue_names.at(0) << ":" << bonds.at(0) << "-" << residue_names.at(1) << ":" << bonds.at(1) << "_" << bond_type;
    bonds_[ss.str()] = bond;
}
void TopologyFile::SetBondTypes(TopologyBondTypeMap bond_types)
{
    bond_types_.clear();
    for(TopologyBondTypeMap::iterator it = bond_types.begin(); it != bond_types.end(); it++)
    {
        int index = (*it).first;
        TopologyFileSpace::TopologyBondType* bond_type = (*it).second;
        bond_types_[index] = bond_type;
    }
}
void TopologyFile::AddBondType(TopologyFileSpace::TopologyBondType *bond_type)
{
    int index = bond_type->GetIndex();
    bond_types_[index] = bond_type;
}
void TopologyFile::SetAngles(TopologyAngleMap angles)
{
    angles_.clear();
    for(TopologyAngleMap::iterator it = angles.begin(); it != angles.end(); it++)
    {
        std::string atom_angle = (*it).first;
        TopologyAngle* angle = (*it).second;
        angles_[atom_angle] = angle;
    }
}
void TopologyFile::AddAngle(TopologyAngle *angle)
{
    std::vector<std::string> angles = angle->GetAngles();
    std::vector<std::string> residue_names = angle->GetResidueNames();
    TopologyFileSpace::TopologyAngleType* angle_type = angle->GetAngleType();
    std::stringstream ss;
    ss << residue_names.at(0) << ":" << angles.at(0) << "-" << residue_names.at(1) << ":" << angles.at(1) << "-" << residue_names.at(2) << ":" << angles.at(2) << "_" << angle_type;
    angles_[ss.str()] = angle;
}
void TopologyFile::SetAngleTypes(TopologyAngleTypeMap angle_types)
{
    angle_types_.clear();
    for(TopologyAngleTypeMap::iterator it = angle_types.begin(); it != angle_types.end(); it++)
    {
        int index = (*it).first;
        TopologyFileSpace::TopologyAngleType* angle_type = (*it).second;
        angle_types_[index] = angle_type;
    }
}
void TopologyFile::AddAngleType(TopologyFileSpace::TopologyAngleType *angle_type)
{
    int index = angle_type->GetIndex();
    angle_types_[index] = angle_type;
}
void TopologyFile::SetDihedrals(TopologyDihedralMap dihedrals)
{
    dihedrals_.clear();
    for(TopologyDihedralMap::iterator it = dihedrals.begin(); it != dihedrals.end(); it++)
    {
        std::string atom_dihedral = (*it).first;
        TopologyDihedral* dihedral = (*it).second;
        dihedrals_[atom_dihedral] = dihedral;
    }
}
void TopologyFile::AddDihedral(TopologyDihedral *dihedral)
{
    std::vector<std::string> dihedrals = dihedral->GetDihedrals();
    std::vector<std::string> residue_names = dihedral->GetResidueNames();
    TopologyFileSpace::TopologyDihedralType* dihedral_type = dihedral->GetDihedralType();
    std::stringstream ss;
    ss << residue_names.at(0) << ":" << dihedrals.at(0) << "-" << residue_names.at(1) << ":" << dihedrals.at(1) << "-"
       << residue_names.at(2) << ":" << dihedrals.at(2) << "-" << residue_names.at(3) << ":" << dihedrals.at(3) << "_" << dihedral_type;
    dihedrals_[ss.str()] = dihedral;
}
void TopologyFile::SetDihedralTypes(TopologyDihedralTypeMap dihedral_types)
{
    dihedral_types_.clear();
    for(TopologyDihedralTypeMap::iterator it = dihedral_types.begin(); it != dihedral_types.end(); it++)
    {
        int index = (*it).first;
        TopologyFileSpace::TopologyDihedralType* dihedral_type = (*it).second;
        dihedral_types_[index] = dihedral_type;
    }
}
void TopologyFile::AddDihedralType(TopologyFileSpace::TopologyDihedralType *dihedral_type)
{
    int index = dihedral_type->GetIndex();
    dihedral_types_[index] = dihedral_type;
}
void TopologyFile::SetAtomPairs(TopologyAtomPairMap pairs)
{
    pairs_.clear();
    for(TopologyAtomPairMap::iterator it = pairs.begin(); it != pairs.end(); it++)
    {
        std::string atom_pair_types = (*it).first;
        TopologyFileSpace::TopologyAtomPair* pair = (*it).second;
        pairs_[atom_pair_types] = pair;
    }
}
void TopologyFile::AddAtomPair(TopologyFileSpace::TopologyAtomPair *pair)
{
    std::string atom_pair_types = pair->GetPairType();
    pairs_[atom_pair_types] = pair;
}

//////////////////////////////////////////////////////////
//                        FUNCTIONS                     //
//////////////////////////////////////////////////////////
void TopologyFile::Read(std::ifstream &in_file)
{
    this->ParseSections(in_file);
}

void TopologyFile::ParseSections(std::ifstream &in_stream)
{

    std::string line;
    /// Unable to read file
    if (!getline(in_stream, line))
    {
        throw TopologyFileProcessingException("Error reading file");
    }
    std::stringstream other;
    std::vector<std::string> atom_names = std::vector<std::string>();
    std::vector<double> charges = std::vector<double>();
    std::vector<int> atomic_numbers = std::vector<int>();
    std::vector<double> masses = std::vector<double>();
    std::vector<int> atom_type_indexes = std::vector<int>();
    std::vector<int> number_excluded_atoms = std::vector<int>();
    std::vector<int> nonbonded_parm_indexes = std::vector<int>();
    std::vector<std::string> residue_labels = std::vector<std::string>();
    std::vector<int> residue_pointers = std::vector<int>();
    std::vector<double> bond_force_constants = std::vector<double>();
    std::vector<double> bond_equil_values = std::vector<double>();
    std::vector<double> angle_force_constants = std::vector<double>();
    std::vector<double> angle_equil_values = std::vector<double>();
    std::vector<double> dihedral_force_constants = std::vector<double>();
    std::vector<double> dihedral_periodicities = std::vector<double>();
    std::vector<double> dihedral_phases = std::vector<double>();
    std::vector<double> scee_scale_factors = std::vector<double>();
    std::vector<double> scnb_scale_factors = std::vector<double>();
    std::vector<double> lennard_jones_acoefs = std::vector<double>();
    std::vector<double> lennard_jones_bcoefs = std::vector<double>();
    std::vector<int> bonds_inc_hydrogens = std::vector<int>();
    std::vector<int> bonds_without_hydrogens = std::vector<int>();
    std::vector<int> angles_inc_hydrogens = std::vector<int>();
    std::vector<int> angles_without_hydrogens = std::vector<int>();
    std::vector<int> dihedrals_inc_hydrogens = std::vector<int>();
    std::vector<int> dihedrals_without_hydrogens = std::vector<int>();
    std::vector<int> excluded_atoms_lists = std::vector<int>();
    std::vector<double> hbond_acoefs = std::vector<double>();
    std::vector<double> hbond_bcoefs = std::vector<double>();
    std::vector<double> hb_cuts = std::vector<double>();
    std::vector<std::string> amber_atom_types = std::vector<std::string>();
    std::vector<std::string> tree_chain_classifications = std::vector<std::string>();
    std::vector<int> solvent_pointers = std::vector<int>();
    std::vector<int> atoms_per_molecule = std::vector<int>();
    std::vector<double> box_dimensions = std::vector<double>();
    std::vector<std::string> radius_sets = std::vector<std::string>();
    std::vector<double> radiis = std::vector<double>();
    std::vector<double> screens = std::vector<double>();
    std::vector<int> ipols = std::vector<int>();
    while(!line.empty())
    {

        if(line.find("%FLAG") != std::string::npos)
        {
            std::stringstream section;
            PartitionSection(in_stream, line, section);
            std::string in_line;
            getline(section, in_line);
            if(in_line.find("%FLAG TITLE") != std::string::npos)
            {
                ParseTitlePartition(section);
            }
            else if(in_line.find("%FLAG POINTERS") != std::string::npos)
            {
                ParsePointersPartition(section);
            }
            else if(in_line.find("%FLAG ATOM_NAME") != std::string::npos)
            {
                atom_names = ParsePartition<std::string>(section);
            }
            else if(in_line.find("%FLAG CHARGE") != std::string::npos)
            {
                charges = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG ATOMIC_NUMBER") != std::string::npos)
            {
                atomic_numbers = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG MASS") != std::string::npos)
            {
                masses = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG ATOM_TYPE_INDEX") != std::string::npos)
            {
                atom_type_indexes = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG NUMBER_EXCLUDED_ATOMS") != std::string::npos)
            {
                number_excluded_atoms =ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG NONBONDED_PARM_INDEX") != std::string::npos)
            {
                nonbonded_parm_indexes = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG RESIDUE_LABEL") != std::string::npos)
            {
                residue_labels = ParsePartition<std::string>(section);
            }
            else if(in_line.find("%FLAG RESIDUE_POINTER") != std::string::npos)
            {
                residue_pointers = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG BOND_FORCE_CONSTANT") != std::string::npos)
            {
                bond_force_constants = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG BOND_EQUIL_VALUE") != std::string::npos)
            {
                bond_equil_values = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG ANGLE_FORCE_CONSTANT") != std::string::npos)
            {
                angle_force_constants = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG ANGLE_EQUIL_VALUE") != std::string::npos)
            {
                angle_equil_values = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG DIHEDRAL_FORCE_CONSTANT") != std::string::npos)
            {
                dihedral_force_constants = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG DIHEDRAL_PERIODICITY") != std::string::npos)
            {
                dihedral_periodicities = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG DIHEDRAL_PHASE") != std::string::npos)
            {
                dihedral_phases = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG SCEE_SCALE_FACTOR") != std::string::npos)
            {
                scee_scale_factors = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG SCNB_SCALE_FACTOR") != std::string::npos)
            {
                scnb_scale_factors = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG SOLTY") != std::string::npos)
            {

            }
            else if(in_line.find("%FLAG LENNARD_JONES_ACOEF") != std::string::npos)
            {
                lennard_jones_acoefs = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG LENNARD_JONES_BCOEF") != std::string::npos)
            {
                lennard_jones_bcoefs = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG BONDS_INC_HYDROGEN") != std::string::npos)
            {
                bonds_inc_hydrogens = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG BONDS_WITHOUT_HYDROGEN") != std::string::npos)
            {
                bonds_without_hydrogens = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG ANGLES_INC_HYDROGEN") != std::string::npos)
            {
                angles_inc_hydrogens = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG ANGLES_WITHOUT_HYDROGEN") != std::string::npos)
            {
                angles_without_hydrogens = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG DIHEDRALS_INC_HYDROGEN") != std::string::npos)
            {
                dihedrals_inc_hydrogens = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG DIHEDRALS_WITHOUT_HYDROGEN") != std::string::npos)
            {
                dihedrals_without_hydrogens = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG EXCLUDED_ATOMS_LIST") != std::string::npos)
            {
                excluded_atoms_lists = ParsePartition<int>(section);
            }
            else if(in_line.find("%FLAG HBOND_ACOEF") != std::string::npos)
            {
                hbond_acoefs = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG HBOND_BCOEF") != std::string::npos)
            {
                hbond_bcoefs = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG HBCUT") != std::string::npos)
            {
                hb_cuts = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG AMBER_ATOM_TYPE") != std::string::npos)
            {
                amber_atom_types = ParsePartition<std::string>(section);
            }
            else if(in_line.find("%FLAG TREE_CHAIN_CLASSIFICATION") != std::string::npos)
            {
                tree_chain_classifications = ParsePartition<std::string>(section);
            }
            else if(in_line.find("%FLAG JOIN_ARRAY") != std::string::npos)
            {
            }
            else if(in_line.find("%FLAG IROTAT") != std::string::npos)
            {
            }
            else if(in_line.find("%FLAG RADIUS_SET") != std::string::npos)
            {
                radius_sets = ParsePartition<std::string>(section);
            }
            else if(in_line.find("%FLAG RADII") != std::string::npos)
            {
                radiis = ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG SCREEN") != std::string::npos)
            {
                screens= ParsePartition<double>(section);
            }
            else if(in_line.find("%FLAG SOLVENT_POINTERS") != std::string::npos)
            {
                solvent_pointers = ParsePartition<int>(section);

//                std::cout<<"Printing Solvent Pointers value"<<std::endl;
                for (unsigned int x = 0; x != solvent_pointers.size(); ++x)
                {
                    // std::cout << example[x] << "- subscripting" << std::endl;
//                     std::cout << solvent_pointers.at(x) << " ";
                }

            }
            else if(in_line.find("%FLAG ATOMS_PER_MOLECULE") != std::string::npos)
            {
                atoms_per_molecule = ParsePartition<int>(section);
//                std::cout<<"Printing atoms_per_molecule value"<<std::endl;
                for (unsigned int x = 0; x != atoms_per_molecule.size(); ++x)
                {
                    // std::cout << example[x] << "- subscripting" << std::endl;
//                     std::cout << atoms_per_molecule.at(x) << " ";
                }
            }
            else if(in_line.find("%FLAG BOX_DIMENSIONS") != std::string::npos)
            {
               box_dimensions = ParsePartition<double>(section);
//               std::cout<<"Printing box_dimensions value"<<std::endl;
               for (unsigned int x = 0; x != box_dimensions.size(); ++x)
               {
                   // std::cout << example[x] << "- subscripting" << std::endl;
//                    std::cout << box_dimensions.at(x) << " ";
               }
            }
            else if(in_line.find("%FLAG CAP_INFO") != std::string::npos)
            {
            }
            else if(in_line.find("%FLAG CAP_INFO2") != std::string::npos)
            {
            }
            else if(in_line.find("%FLAG IPOL") != std::string::npos)
            {
                ipols = ParsePartition<int>(section);
            }
            else
            {
                // Ignore section
            }
        }
        else
        {
            other << line << std::endl;
            getline(in_stream, line);
        }
    }
    // Bond types
    for(int i = 0; i < number_of_bond_types_; i++)
    {
        bond_types_[i] = new TopologyFileSpace::TopologyBondType(i, bond_force_constants.at(i), bond_equil_values.at(i));
    }
    // Angle types
    for(int i = 0; i < number_of_angle_types_; i++)
    {
        angle_types_[i] = new TopologyFileSpace::TopologyAngleType(i, angle_force_constants.at(i), angle_equil_values.at(i));
    }
    // Dihedral types
    for(int i = 0; i < number_of_dihedral_types_; i++)
    {
        dihedral_types_[i] = new TopologyFileSpace::TopologyDihedralType(i, dihedral_force_constants.at(i), dihedral_periodicities.at(i), dihedral_phases.at(i),
                                                      scee_scale_factors.at(i), scnb_scale_factors.at(i));
    }
    // Radius set
    for(RadiusSet::iterator it = radius_sets.begin(); it != radius_sets.end(); it++)
    {
        radius_set_.push_back(*it);
    }

    // Lennard Jones coefficients for atom pairs
    if(nonbonded_parm_indexes.size() != number_of_types_ * number_of_types_)
    {
//        std::cout << "Lennard Jones coefficients section of the file is not written properly. This section will be ignored!" << std::endl;
        gmml::log(__LINE__, __FILE__, gmml::INF, "Lennard Jones coefficients section of the file is not written properly. This section will be ignored!");
    }
    else
    {
        for(int i = 0; i < number_of_atoms_; i++)
        {
            std::string atom_type_1 = amber_atom_types.at(i);
            for(int j = 0; j < number_of_atoms_; j++)
            {
                std::string atom_type_2 = amber_atom_types.at(j);
                double coefficient_a;
                double coefficient_b;
                int index = nonbonded_parm_indexes.at(number_of_types_ * (atom_type_indexes.at(i) - 1) + atom_type_indexes.at(j) - 1);
                if(index > 0)
                {
                    coefficient_a = lennard_jones_acoefs.at(index - 1);
                    coefficient_b = lennard_jones_bcoefs.at(index - 1);
                }
                else
                {
                    coefficient_a = hbond_acoefs.at(index - 1);
                    coefficient_b = hbond_bcoefs.at(index - 1);
                }
                if(pairs_.find(atom_type_1 + "-" + atom_type_2) != pairs_.end()|| pairs_.find(atom_type_2 + "-" + atom_type_1) != pairs_.end())
                {

                }
                else
                {
                    pairs_[atom_type_1 + "-" + atom_type_2] = new TopologyFileSpace::TopologyAtomPair(atom_type_1 + "-" + atom_type_2, coefficient_a, coefficient_b, index);
//                    std::cout << atom_type_1 + "-" + atom_type_2 << ":" << index << std::endl;
                }
            }

        }
    }

    // Bonds, Angles, Dihedrals
    //Bonds in topology file
    for(int i = 0; i < number_of_bonds_including_hydrogen_; i++)
    {
        std::vector<std::string> bonds = std::vector<std::string>();
        std::vector<std::string> bond_atoms_residue_names = std::vector<std::string>();

        int first_atom_index = (bonds_inc_hydrogens[i*3])/3;
        int second_atom_index = (bonds_inc_hydrogens[i*3+1])/3;

        bonds.push_back(atom_names[first_atom_index] + "(" + gmml::ConvertT<int>(first_atom_index+1) + ")");
        bonds.push_back(atom_names[second_atom_index] + "(" + gmml::ConvertT<int>(second_atom_index+1) + ")");

        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(first_atom_index >= start_index && first_atom_index < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                bond_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(second_atom_index >= start_index && second_atom_index < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                bond_atoms_residue_names.push_back(r.str());
                break;
            }
        }

        TopologyBond* topology_bond = new TopologyBond(bonds, bond_atoms_residue_names);

        topology_bond->SetBondType(bond_types_[bonds_inc_hydrogens[i*3+2] - 1]);
        topology_bond->SetIncludingHydrogen(true);

        std::stringstream key;
        key << bond_atoms_residue_names.at(0) << ":" << bonds.at(0) << "-" << bond_atoms_residue_names.at(1) << ":" << bonds.at(1) << "_" << topology_bond->GetBondType();
        bonds_[key.str()] = topology_bond;
    }
    for(int i = 0; i < number_of_bonds_excluding_hydrogen_; i++)
    {
        std::vector<std::string> bonds = std::vector<std::string>();
        std::vector<std::string> bond_atoms_residue_names = std::vector<std::string>();

        int first_atom_index = (bonds_without_hydrogens[i*3])/3;
        int second_atom_index = (bonds_without_hydrogens[i*3+1])/3;

        bonds.push_back(atom_names[first_atom_index] + "(" + gmml::ConvertT<int>(first_atom_index+1) + ")");
        bonds.push_back(atom_names[second_atom_index] + "(" + gmml::ConvertT<int>(second_atom_index+1) + ")");

        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j <number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(first_atom_index >= start_index && first_atom_index < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                bond_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int end_index;
            int start_index = residue_pointers.at(j) - 1;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(second_atom_index >= start_index && second_atom_index < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                bond_atoms_residue_names.push_back(r.str());
                break;
            }
        }

        TopologyBond* topology_bond = new TopologyBond(bonds, bond_atoms_residue_names);

        topology_bond->SetBondType(bond_types_[bonds_without_hydrogens[i*3+2] - 1]);
        topology_bond->SetIncludingHydrogen(false);

        std::stringstream key;
        key << bond_atoms_residue_names.at(0) << ":" << bonds.at(0) << "-" << bond_atoms_residue_names.at(1) << ":" << bonds.at(1) << "_" << topology_bond->GetBondType();
        bonds_[key.str()] = topology_bond;
    }

    // Angles in topology file
    // Angles including hydrogen
    for(int i = 0; i < number_of_angles_including_hydrogen_; i++)
    {
        std::vector<std::string> angle_atoms = std::vector<std::string>();
        std::vector<std::string> angle_atoms_residue_names = std::vector<std::string>();

        int atom_index_1 = angles_inc_hydrogens.at(i*4) / 3;
        int atom_index_2 = angles_inc_hydrogens.at(i*4+1) / 3;
        int atom_index_3 = angles_inc_hydrogens.at(i*4+2) / 3;

        angle_atoms.push_back(atom_names.at(atom_index_1) + "(" + gmml::ConvertT<int>(atom_index_1+1) + ")");
        angle_atoms.push_back(atom_names.at(atom_index_2) + "(" + gmml::ConvertT<int>(atom_index_2+1) + ")");
        angle_atoms.push_back(atom_names.at(atom_index_3) + "(" + gmml::ConvertT<int>(atom_index_3+1) + ")");

        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_1 >= start_index && atom_index_1 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                angle_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_2 >= start_index && atom_index_2 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                angle_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_3 >= start_index && atom_index_3 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                angle_atoms_residue_names.push_back(r.str());
                break;
            }
        }

        TopologyAngle* angle = new TopologyAngle(angle_atoms, angle_atoms_residue_names);

        angle->SetIncludingHydrogen(true);
        angle->SetAnlgeType(angle_types_[angles_inc_hydrogens.at(i*4+3) - 1]);

        std::stringstream key;
        key << angle_atoms_residue_names.at(0) << ":" << angle_atoms.at(0) << "-" << angle_atoms_residue_names.at(1) << ":" << angle_atoms.at(1) << "-"
            << angle_atoms_residue_names.at(2) << ":" << angle_atoms.at(2) << "_" << angle->GetAngleType();
        angles_[key.str()] = angle;
    }

    // Angles excluding hydrogen
    for(int i = 0; i < number_of_angles_excluding_hydrogen_; i++)
    {
        std::vector<std::string> angle_atoms = std::vector<std::string>();
        std::vector<std::string> angle_atoms_residue_names = std::vector<std::string>();

        int atom_index_1 = angles_without_hydrogens.at(i*4) / 3;
        int atom_index_2 = angles_without_hydrogens.at(i*4+1) / 3;
        int atom_index_3 = angles_without_hydrogens.at(i*4+2) / 3;

        angle_atoms.push_back(atom_names.at(atom_index_1) + "(" + gmml::ConvertT<int>(atom_index_1+1) + ")");
        angle_atoms.push_back(atom_names.at(atom_index_2) + "(" + gmml::ConvertT<int>(atom_index_2+1) + ")");
        angle_atoms.push_back(atom_names.at(atom_index_3) + "(" + gmml::ConvertT<int>(atom_index_3+1) + ")");

        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_1 >= start_index && atom_index_1 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                angle_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_2 >= start_index && atom_index_2 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                angle_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int end_index;
            int start_index = residue_pointers.at(j) - 1;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_3 >= start_index && atom_index_3 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                angle_atoms_residue_names.push_back(r.str());
                break;
            }
        }

        TopologyAngle* angle = new TopologyAngle(angle_atoms, angle_atoms_residue_names);

        angle->SetIncludingHydrogen(false);
        angle->SetAnlgeType(angle_types_[angles_without_hydrogens.at(i*4+3) - 1]);

        std::stringstream key;
        key << angle_atoms_residue_names.at(0) << ":" << angle_atoms.at(0) << "-" << angle_atoms_residue_names.at(1) << ":" << angle_atoms.at(1) << "-"
            << angle_atoms_residue_names.at(2) << ":" << angle_atoms.at(2) << "_" << angle->GetAngleType();
        angles_[key.str()] = angle;
    }

    // Dihedrals in topology file
    // Dihedrals including hydrogen
    for(int i = 0; i < number_of_dihedrals_including_hydrogen_; i++)
    {
        std::vector<std::string> dihedral_atoms = std::vector<std::string>();
        std::vector<std::string> dihedral_atoms_residue_names = std::vector<std::string>();

        int atom_index_1 = abs(dihedrals_inc_hydrogens.at(i*5)) / 3;
        int atom_index_2 = abs(dihedrals_inc_hydrogens.at(i*5+1)) / 3;
        int atom_index_3 = abs(dihedrals_inc_hydrogens.at(i*5+2)) / 3;
        int atom_index_4 = abs(dihedrals_inc_hydrogens.at(i*5+3)) / 3;

        dihedral_atoms.push_back(atom_names.at(atom_index_1) + "(" + gmml::ConvertT<int>(atom_index_1+1) + ")");
        dihedral_atoms.push_back(atom_names.at(atom_index_2) + "(" + gmml::ConvertT<int>(atom_index_2+1) + ")");
        dihedral_atoms.push_back(atom_names.at(atom_index_3) + "(" + gmml::ConvertT<int>(atom_index_3+1) + ")");
        dihedral_atoms.push_back(atom_names.at(atom_index_4) + "(" + gmml::ConvertT<int>(atom_index_4+1) + ")");

        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_1 >= start_index && atom_index_1 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_2 >= start_index && atom_index_2 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_3 >= start_index && atom_index_3 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_4 >= start_index && atom_index_4 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }

        TopologyDihedral* dihedral = new TopologyDihedral(dihedral_atoms, dihedral_atoms_residue_names);

        if(dihedrals_inc_hydrogens.at(i*5+2) < 0)
            dihedral->SetIgnoredGroupInteraction(true);
        else
            dihedral->SetIgnoredGroupInteraction(false);
        if(dihedrals_inc_hydrogens.at(i*5+3) < 0)
            dihedral->SetIsImproper(true);
        else
            dihedral->SetIsImproper(false);

        dihedral->SetIncludingHydrogen(true);

        dihedral->SetDihedralType(dihedral_types_[dihedrals_inc_hydrogens.at(i*5+4) - 1]);
        std::stringstream key;
        key << dihedral_atoms_residue_names.at(0) << ":" << dihedral_atoms.at(0) << "-" << dihedral_atoms_residue_names.at(1) << ":" << dihedral_atoms.at(1) << "-"
            << dihedral_atoms_residue_names.at(2) << ":" << dihedral_atoms.at(2) << "-" << dihedral_atoms_residue_names.at(3) << ":" << dihedral_atoms.at(3) << "_"
            << dihedral->GetDihedralType()->GetIndex() << "_"
            << (dihedral->GetIsImproper() ? "IY" : "IN") << "_" << (dihedral->GetIgnoredGroupInteraction() ? "GY" : "GN");
        dihedrals_[key.str()] = dihedral;


    }
    // Dihedrals excluding hydrogen
    for(int i = 0; i < number_of_dihedrals_excluding_hydrogen_; i++)
    {
        std::vector<std::string> dihedral_atoms = std::vector<std::string>();
        std::vector<std::string> dihedral_atoms_residue_names = std::vector<std::string>();

        int atom_index_1 = abs(dihedrals_without_hydrogens.at(i*5)) / 3;
        int atom_index_2 = abs(dihedrals_without_hydrogens.at(i*5+1)) / 3;
        int atom_index_3 = abs(dihedrals_without_hydrogens.at(i*5+2)) / 3;
        int atom_index_4 = abs(dihedrals_without_hydrogens.at(i*5+3)) / 3;

        dihedral_atoms.push_back(atom_names.at(atom_index_1) + "(" + gmml::ConvertT<int>(atom_index_1+1) + ")");
        dihedral_atoms.push_back(atom_names.at(atom_index_2) + "(" + gmml::ConvertT<int>(atom_index_2+1) + ")");
        dihedral_atoms.push_back(atom_names.at(atom_index_3) + "(" + gmml::ConvertT<int>(atom_index_3+1) + ")");
        dihedral_atoms.push_back(atom_names.at(atom_index_4) + "(" + gmml::ConvertT<int>(atom_index_4+1) + ")");

        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_1 >= start_index && atom_index_1 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_2 >= start_index && atom_index_2 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_3 >= start_index && atom_index_3 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }
        for(int j = 0; j < number_of_residues_; j++)
        {
            int start_index = residue_pointers.at(j) - 1;
            int end_index;
            if(j < number_of_residues_ - 1)
            {
                end_index = residue_pointers.at(j+1) - 1;
            }
            else
            {
                end_index = number_of_atoms_;
            }
            if(atom_index_4 >= start_index && atom_index_4 < end_index)
            {
                std::stringstream r;
                r << residue_labels.at(j) << "(" << (j+1) << ")";
                dihedral_atoms_residue_names.push_back(r.str());
                break;
            }
        }

        TopologyDihedral* dihedral = new TopologyDihedral(dihedral_atoms, dihedral_atoms_residue_names);

        if(dihedrals_without_hydrogens.at(i*5+2) < 0)
            dihedral->SetIgnoredGroupInteraction(true);
        else
            dihedral->SetIgnoredGroupInteraction(false);
        if(dihedrals_without_hydrogens.at(i*5+3) < 0)
            dihedral->SetIsImproper(true);
        else
            dihedral->SetIsImproper(false);

        dihedral->SetIncludingHydrogen(false);
        dihedral->SetDihedralType(dihedral_types_[dihedrals_without_hydrogens.at(i*5+4) - 1]);

        std::stringstream key;
        key << dihedral_atoms_residue_names.at(0) << ":" << dihedral_atoms.at(0) << "-" << dihedral_atoms_residue_names.at(1) << ":" << dihedral_atoms.at(1) << "-"
            << dihedral_atoms_residue_names.at(2) << ":" << dihedral_atoms.at(2) << "-" << dihedral_atoms_residue_names.at(3) << ":" << dihedral_atoms.at(3) << "_"
            << dihedral->GetDihedralType()->GetIndex() << "_"
            << (dihedral->GetIsImproper() ? "IY" : "IN") << "_" << (dihedral->GetIgnoredGroupInteraction() ? "GY" : "GN");
        dihedrals_[key.str()] = dihedral;
    }
    // Residues in topology file
    int start_index = 0;
    TopologyFileSpace::TopologyAssembly::TopologyResidueVector residues;
    for(std::vector<std::string>::iterator it = residue_labels.begin(); it != residue_labels.end(); it++)
    {
        std::string residue_name = *it;
        TopologyResidue::TopologyAtomVector atoms;
        int residue_index = distance(residue_labels.begin(), it) + 1;
        int starting_atom_index = residue_pointers.at(residue_index - 1);
        int ending_atom_index;


        if(residue_index < number_of_residues_)
        {
            ending_atom_index = residue_pointers.at(residue_index);
        }
        else
        {
            ending_atom_index = number_of_atoms_ + 1;
        }
        for(int i = starting_atom_index - 1; i < ending_atom_index - 1; i++)
        {
            TopologyAtom::ExcludedAtomNames excluded_atoms = TopologyAtom::ExcludedAtomNames();
            if(i > 0)
                start_index += number_excluded_atoms.at(i-1);
            for(int j = start_index; j < start_index + number_excluded_atoms.at(i); j++)
            {
                std::string excluded_atom_residue_name;
                int index = (excluded_atoms_lists.at(j) - 1 == -1) ? 0 : excluded_atoms_lists.at(j) - 1;
                for(int k = 0; k < number_of_residues_; k++)
                {
                    int start_atom_index = residue_pointers.at(k) - 1;
                    int end_atom_index;
                    if(k < number_of_residues_ - 1)
                    {
                        end_atom_index = residue_pointers.at(k+1) - 1;
                    }
                    else
                    {
                        end_atom_index = number_of_atoms_;
                    }
                    if(index >= start_atom_index && index < end_atom_index)
                    {

                        excluded_atom_residue_name = residue_labels.at(k) + "(" + gmml::ConvertT<int>(k+1) + ")";
                        break;
                    }
                }
                excluded_atoms.push_back(excluded_atom_residue_name + ":" + atom_names.at(index) + "(" + gmml::ConvertT<int>(index+1) + ")");
            }
            atoms.push_back(new TopologyAtom(i + 1, atom_names.at(i), amber_atom_types.at(i), charges.at(i), atomic_numbers.at(i), masses.at(i), excluded_atoms,
                                                       number_excluded_atoms.at(i), radiis.at(i), screens.at(i), tree_chain_classifications.at(i), residue_name));
        }
        std::stringstream residue_key;
        residue_key << residue_name << "_" << gmml::BLANK_SPACE << "_" << residue_index;
        residues.push_back(new TopologyResidue(residue_name, atoms, residue_index, starting_atom_index)); //edited by Ayush on 06/30/17 for Solvent
    }

    assembly_ = new TopologyFileSpace::TopologyAssembly();
    assembly_->SetAssemblyName(title_);
    assembly_->SetResidues(residues);
}

void TopologyFile::PartitionSection(std::ifstream &stream, std::string &line, std::stringstream& section)
{
    while(line[0] == '%')
    {
        if(line.find("%FLAG") != std::string::npos)
        {
            section << line << std::endl;
        }
        if(line.find("%FORMAT") != std::string::npos)
        {
            section << line << std::endl;
        }
        getline(stream, line);
    }
    while(line[0] != '%')
    {
        section << line << std::endl;
        getline(stream, line);
        if(line.empty())
            break;
    }
}

void TopologyFile::ParseTitlePartition(std::stringstream& stream)
{
    std::string line;
    // Section Header
    getline(stream, line);
    // Section Format
    getline(stream, line);
    while(!line.empty())
    {
        std::string format = "20a4";
        if(line[0] == '%')
        {
            if(line.find("%FORMAT") != std::string::npos)
            {
                format = line.substr(line.find_first_of('(', 0) + 1, line.find_last_of(')', line.length()) - line.find_first_of('(', 0) - 1);
            }
        }
        else
        {
            title_ += line;
        }
        getline(stream, line);
    }
    title_ = gmml::Trim(title_);
}

void TopologyFile::ParsePointersPartition(std::stringstream &stream)
{
    std::string line;
    std::vector<int> items = std::vector<int>();
    // Section Header
    getline(stream, line);
    // Section Format
    getline(stream, line);
    while(!line.empty())
    {
        std::string format = "10I8";
        if(line[0] == '%')
        {
            if(line.find("%FORMAT") != std::string::npos)
            {
                format = line.substr(line.find_first_of('(', 0) + 1, line.find_last_of(')', line.length()) - line.find_first_of('(', 0) - 1);
            }
        }
        else
        {
            std::vector<int> line_items = PartitionLine<int>(line, format);
            for(std::vector<int>::iterator it = line_items.begin(); it != line_items.end(); it++)
            {
                items.push_back(*it);
            }
        }
        getline(stream, line);
    }
    number_of_atoms_ = items.at(0);
    number_of_types_ = items.at(1);
    number_of_bonds_including_hydrogen_ = items.at(2);
    number_of_bonds_excluding_hydrogen_ = items.at(3);
    number_of_angles_including_hydrogen_ = items.at(4);
    number_of_angles_excluding_hydrogen_ = items.at(5);
    number_of_dihedrals_including_hydrogen_ = items.at(6);
    number_of_dihedrals_excluding_hydrogen_ = items.at(7);
    number_of_hydrogen_parameters_ = items.at(8);
    number_of_parameters_ = items.at(9);
    number_of_excluded_atoms_ = items.at(10);
    number_of_residues_ = items.at(11);
    total_number_of_bonds_ = items.at(12);
    total_number_of_angles_ = items.at(13);
    total_number_of_dihedrals_ = items.at(14);
    number_of_bond_types_ = items.at(15);
    number_of_angle_types_ = items.at(16);
    number_of_dihedral_types_ = items.at(17);
    number_of_atom_types_in_parameter_file_ = items.at(18);
    number_of_distinct_hydrogen_bonds_ = items.at(19);
    perturbation_option_ = items.at(20);
    number_of_bonds_perturbed_ = items.at(21);
    number_of_angles_perturbed_ = items.at(22);
    number_of_dihedrals_perturbed_ = items.at(23);
    number_of_bonds_group_perturbed_ = items.at(24);
    number_of_angles_group_perturbed_ = items.at(25);
    number_of_dihedrals_group_perturbed_ = items.at(26);
    standard_periodic_box_option_ = items.at(27);
    number_of_atoms_in_largest_residue_ = items.at(28);
    cap_option_ = items.at(29);
    number_of_extra_points_ = items.at(30);
    if(items.size() >= 31)
        number_of_beads_ = items.at(30);
}

template<typename T>
std::vector<T> TopologyFile::ParsePartition(std::stringstream &stream)
{
    std::string line;
    std::vector<T> section = std::vector<T>();
    getline(stream, line);
    std::string format;
    while(!line.empty())
    {
        if(line[0] == '%')
        {
            if(line.find("%FORMAT") != std::string::npos)
            {
                format = line.substr(line.find_first_of('(', 0) + 1, line.find_last_of(')', line.length()) - line.find_first_of('(', 0) - 1);
            }
        }
        else
        {
            std::vector<T> line_items = PartitionLine<T>(line, format);
            for(typename std::vector<T>::iterator it = line_items.begin(); it != line_items.end(); it++)
            {
                section.push_back(*it);
                //Printing to check if the value is read or not ---Need to delete
                //std::cout<<*it;
            }
            // new line ---Need to delete
          //  std::std::cout << "\n";
        }
        getline(stream, line);
    }
    return section;

}

template<typename T>
std::vector<T> TopologyFile::PartitionLine(std::string line, std::string format)
{
    std::vector<T> items = std::vector<T>();
    if(format.compare("10I8") == 0)
    {
        int number_of_items = 10;
        int item_length = 8;
        for(int i = 0; i < number_of_items && item_length * (i+1) <= (int)line.length(); i++)
        {
            std::string token = line.substr(i*item_length, item_length);
            token = gmml::Trim(token);
            items.push_back(gmml::ConvertString<T>(token));
        }
        return items;
    }
    if(format.compare("20a4") == 0)
    {
        int number_of_items = 20;
        int item_length = 4;
        for(int i = 0; i < number_of_items && item_length * (i+1) <= (int)line.length(); i++)
        {
            std::string token = line.substr(i*item_length, item_length);
            token = gmml::Trim(token);
            items.push_back(gmml::ConvertString<T>(token));
        }
        return items;
    }
    if(format.compare("5E16.8") == 0)
    {
        int number_of_items = 5;
        int item_length = 16;
        for(int i = 0; i < number_of_items && item_length * (i+1) <= (int)line.length(); i++)
        {
            std::string token = line.substr(i*item_length, item_length);
            token = gmml::Trim(token);
            double base = gmml::ConvertString<double>(gmml::Split(token, "E")[0]);
            int power = gmml::ConvertString<int>(gmml::Split(token, "E")[1]);
            std::stringstream temp, format;
            double result = base * pow(10, power);
            format << std::setw(16) << std::fixed << std::setprecision(8);
            temp << format.str() << result;
            T item = gmml::ConvertString<T>(temp.str());
            items.push_back(item);
        }
        return items;
    }
    if(format.compare("1a80") == 0)
    {
        int number_of_items = 1;
        int item_length = 80;
        for(int i = 0; i < number_of_items && item_length * (i+1) <= (int)line.length(); i++)
        {
            std::string token = line.substr(i*item_length, item_length);
            std::replace_if(token.begin(), token.end(), ::isspace, '#');
            token = gmml::Trim(token);
            items.push_back(gmml::ConvertString<T>(token));
        }

        return items;
    }
    if(format.compare("1I8") == 0)
    {
        int number_of_items = 1;
        int item_length = 8;
        for(int i = 0; i < number_of_items && item_length * (i+1) <= (int)line.length(); i++)
        {
            std::string token = line.substr(i*item_length, item_length);
            token = gmml::Trim(token);
            items.push_back(gmml::ConvertString<T>(token));
        }
        return items;
    }
    if(format.compare("3I8") == 0)
    {
        int number_of_items = 3;
        int item_length = 8;
        for(int i = 0; i < number_of_items && item_length * (i+1) <= (int)line.length(); i++)
        {
            std::string token = line.substr(i*item_length, item_length);
            token = gmml::Trim(token);
            items.push_back(gmml::ConvertString<T>(token));
        }
        return items;
    }
    return items;
}

void TopologyFile::Write(const std::string &top_file)
{
    std::ofstream out_file;
    try
    {
        out_file.open(top_file.c_str());
    }
    catch(...)
    {
        throw TopologyFileProcessingException(__LINE__,"File could not be created");
    }
    try
    {
        this->ResolveSections(out_file);
    }
    catch(...)
    {
        out_file.close();            /// Close the parm7 files
    }
}

void TopologyFile::ResolveSections(std::ofstream &out_stream)
{
    //out_stream << std::endl;
    this->ResolveGitVersion(out_stream);
    this->ResolveTitleSection(out_stream);
    this->ResolvePointersSection(out_stream);
    this->ResolveAtomNameSection(out_stream);
    this->ResolveChargeSection(out_stream);
    this->ResolveAtomicNumberSection(out_stream);
    this->ResolveMassSection(out_stream);
    this->ResolveAtomTypeIndexSection(out_stream);
    this->ResolveNumberExcludedAtomsSection(out_stream);
    this->ResolveNonbondedParmIndexSection(out_stream);
    this->ResolveResidueLabelSection(out_stream);
    this->ResolveResiduePointersSection(out_stream);
    this->ResolveBondForceConstantSection(out_stream);
    this->ResolveBondEquilValueSection(out_stream);
    this->ResolveAngleForceConstantSection(out_stream);
    this->ResolveAngleEquilValueSection(out_stream);
    this->ResolveDihedralForceConstantSection(out_stream);
    this->ResolveDihedralPeriodicitySection(out_stream);
    this->ResolveDihedralPhaseSection(out_stream);
    this->ResolveSceeScaleFactorSection(out_stream);
    this->ResolveScnbScaleFactorSection(out_stream);
    this->ResolveSoltySection(out_stream);
    this->ResolveLennardJonesACoefSection(out_stream);
    this->ResolveLennardJonesBCoefSection(out_stream);
    this->ResolveBondsIncHydrogenSection(out_stream);
    this->ResolveBondsWithoutHydrogenSection(out_stream);
    this->ResolveAnglesIncHydrogenSection(out_stream);
    this->ResolveAnglesWithoutHydrogenSection(out_stream);
    this->ResolveDihedralsIncHydrogenSection(out_stream);
    this->ResolveDihedralsWithoutHydrogenSection(out_stream);
    this->ResolveExcludedAtomsListSection(out_stream);
    this->ResolveHydrogenBondACoefSection(out_stream);
    this->ResolveHydrogenBondBCoefSection(out_stream);
    this->ResolveHBCutSection(out_stream);
    this->ResolveAmberAtomTypeSection(out_stream);
    this->ResolveTreeChainClassificationSection(out_stream);
    this->ResolveJoinArraySection(out_stream);
    this->ResolveIRotatSection(out_stream);
    this->ResolveRadiusSetSection(out_stream);
    this->ResolveRadiiSection(out_stream);
    this->ResolveSolventPointersSection(out_stream); //Added by Ayush for Solvation on 07/11/2017
    this->ResolveScreenSection(out_stream);

}

void TopologyFile::ResolveGitVersion(std::ofstream &out)
{
    out << "%VERSION  VERSION_STAMP = V0001.000 "<< std::endl;

    //char szTmp[32];
    //sprintf(szTmp, "/proc/%d/exe", getpid());
    //int bytes = MIN(readlink(szTmp, pBuf, len), len - 1);
    //if(bytes >= 0)
    //    pBuf[bytes] = '\0';

    // std::string pwdd = execcommand("pwd");
    //std::string cd = execcommand(("cd "+ bytes).c_str());
    //std::string gitversion =  execcommand("git rev-parse HEAD");
    //std::string pwd = system(("pwd").c_str());
    //system(("cd "+pwd).c_str());
    //std::string gitversion = system("git rev-parse HEAD");
    //out << gitversion;
}


void TopologyFile::ResolveTitleSection(std::ofstream &out)
{
    out << "%FLAG TITLE" << std::endl
        << "%FORMAT(20a4)" << std::endl
        << title_ << std::endl;
}

void TopologyFile::ResolvePointersSection(std::ofstream &out)
{
    out << "%FLAG POINTERS" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    if(number_of_atoms_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_atoms_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_types_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_types_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_bonds_including_hydrogen_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_bonds_including_hydrogen_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_bonds_excluding_hydrogen_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_bonds_excluding_hydrogen_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_angles_including_hydrogen_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_angles_including_hydrogen_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_angles_excluding_hydrogen_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_angles_excluding_hydrogen_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_dihedrals_including_hydrogen_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_dihedrals_including_hydrogen_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_dihedrals_excluding_hydrogen_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_dihedrals_excluding_hydrogen_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_hydrogen_parameters_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_hydrogen_parameters_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_parameters_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_parameters_;
    else
        out << std::setw(8) << std::right << 0;
    out << std::endl;
    if(number_of_excluded_atoms_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_excluded_atoms_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_residues_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_residues_;
    else
        out << std::setw(8) << std::right << 0;
    if(total_number_of_bonds_ != gmml::iNotSet)
        out << std::setw(8) << std::right << total_number_of_bonds_;
    else
        out << std::setw(8) << std::right << 0;
    if(total_number_of_angles_ != gmml::iNotSet)
        out << std::setw(8) << std::right << total_number_of_angles_;
    else
        out << std::setw(8) << std::right << 0;
    if(total_number_of_dihedrals_ != gmml::iNotSet)
        out << std::setw(8) << std::right << total_number_of_dihedrals_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_bond_types_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_bond_types_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_angle_types_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_angle_types_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_dihedral_types_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_dihedral_types_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_atom_types_in_parameter_file_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_atom_types_in_parameter_file_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_distinct_hydrogen_bonds_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_distinct_hydrogen_bonds_;
    else
        out << std::setw(8) << std::right << 0;
    out << std::endl;
    if(perturbation_option_ != gmml::iNotSet)
        out << std::setw(8) << std::right << perturbation_option_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_bonds_perturbed_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_bonds_perturbed_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_angles_perturbed_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_angles_perturbed_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_dihedrals_perturbed_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_dihedrals_perturbed_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_bonds_group_perturbed_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_bonds_group_perturbed_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_angles_group_perturbed_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_angles_group_perturbed_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_dihedrals_group_perturbed_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_dihedrals_group_perturbed_;
    else
        out << std::setw(8) << std::right << 0;
    if(standard_periodic_box_option_ != gmml::iNotSet)
        out << std::setw(8) << std::right << standard_periodic_box_option_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_atoms_in_largest_residue_ != gmml::iNotSet)
        out << std::setw(8) << std::right << number_of_atoms_in_largest_residue_;
    else
        out << std::setw(8) << std::right << 0;
    if(cap_option_ != gmml::iNotSet)
        out << std::setw(8) << std::right << cap_option_;
    else
        out << std::setw(8) << std::right << 0;
    out << std::endl;
    if(number_of_extra_points_ != gmml::iNotSet)
        out << std::setw(8) << number_of_extra_points_;
    else
        out << std::setw(8) << std::right << 0;
    if(number_of_beads_ != gmml::iNotSet)
        out << std::setw(8) << number_of_beads_ << std::endl;
    else
        out << std::setw(8) << std::right << 0 << std::endl;
}

void TopologyFile::ResolveAtomNameSection(std::ofstream& out)
{
    out << "%FLAG ATOM_NAME" << std::endl
        << "%FORMAT(20a4)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 20;
    const int ITEM_LENGTH = 4;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            out << std::setw(ITEM_LENGTH) << std::left << atom->GetAtomName();
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveChargeSection(std::ofstream& out)
{
    out << "%FLAG CHARGE" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << atom->GetAtomCharge();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveAtomicNumberSection(std::ofstream& out)
{
    out << "%FLAG ATOMIC_NUMBER" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            if(atom->GetAtomicNumber() != gmml::iNotSet)
                out << std::setw(ITEM_LENGTH) << std::right << atom->GetAtomicNumber();
            else
                out << std::setw(ITEM_LENGTH) << std::right << 0;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveMassSection(std::ofstream& out)
{
    out << "%FLAG MASS" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            std::stringstream ss;
            if(atom->GetAtomMass() != gmml::dNotSet)
                ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << atom->GetAtomMass();
            else
                ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << 0.0;
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveAtomTypeIndexSection(std::ofstream& out)
{
    out << "%FLAG ATOM_TYPE_INDEX" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    TopologyAtomTypeIndexMap atom_type_index_map = this->GetAtomTypeIndexMap();
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            out << std::setw(ITEM_LENGTH) << std::right << atom_type_index_map[atom->GetType()];
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveNumberExcludedAtomsSection(std::ofstream& out)
{
    out << "%FLAG NUMBER_EXCLUDED_ATOMS" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            out << std::setw(ITEM_LENGTH) << std::right << atom->GetExcludedAtoms().size();
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveNonbondedParmIndexSection(std::ofstream& out)
{
    out << "%FLAG NONBONDED_PARM_INDEX" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int index = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;

    TopologyAtomTypeIndexMap atom_type_index_map = this->GetAtomTypeIndexMap();
    std::vector<std::string> atom_types = std::vector<std::string>();
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            atom_types.push_back(atom->GetType());
        }
    }
    std::map<std::string, bool> pair_set = std::map<std::string, bool>();
    std::map<int, int> nonbond_index_map = std::map<int, int>();
    for(int i = 0; i < number_of_atoms_; i++)
    {
        std::string atom_type_1 = atom_types.at(i);
        for(int j = 0; j < number_of_atoms_; j++)
        {
            std::string atom_type_2 = atom_types.at(j);
            if(!pair_set[atom_type_1 + "-" + atom_type_2])
            {
                int nonbond_index = number_of_types_ * (atom_type_index_map[atom_type_1] - 1) + atom_type_index_map[atom_type_2];
                int parameter_index = 0;

                if(pairs_.find(atom_type_1 + "-" + atom_type_2) != pairs_.end())
                {
                    parameter_index = pairs_[atom_type_1 + "-" + atom_type_2]->GetIndex();
                }
                else if(pairs_.find(atom_type_2 + "-" + atom_type_1) != pairs_.end())
                {
                    parameter_index = pairs_[atom_type_2 + "-" + atom_type_1]->GetIndex();
                }
                nonbond_index_map[nonbond_index] = parameter_index;
                pair_set[atom_type_1 + "-" + atom_type_2] = true;
            }
        }
    }
    unsigned size = nonbond_index_map.size();
    for(unsigned int i = 0; i < size; i++)
    {
        out << std::setw(ITEM_LENGTH) << std::right << nonbond_index_map[i+1];
        count++;
        total_count++;
        if(count == MAX_IN_LINE)
        {
            count = 0;
            out << std::endl;
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveResidueLabelSection(std::ofstream& out)
{
    out << "%FLAG RESIDUE_LABEL" << std::endl
        << "%FORMAT(20a4)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 20;
    const int ITEM_LENGTH = 4;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);

        out << std::setw(ITEM_LENGTH) << std::left << residue->GetResidueName();
        count++;
        total_count++;
        if(count == MAX_IN_LINE)
        {
            count = 0;
            out << std::endl;
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveResiduePointersSection(std::ofstream& out)
{
    out << "%FLAG RESIDUE_POINTER" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);

        out << std::setw(ITEM_LENGTH) << std::right << residue->GetStartingAtomIndex();
        count++;
        total_count++;
        if(count == MAX_IN_LINE)
        {
            count = 0;
            out << std::endl;
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveBondForceConstantSection(std::ofstream& out)
{
    out << "%FLAG BOND_FORCE_CONSTANT" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_bond_types_; i++)
    {
        TopologyFileSpace::TopologyBondType* bond_type = this->GetBondTypeByIndex(i);
        if(bond_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << bond_type->GetForceConstant();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveBondEquilValueSection(std::ofstream& out)
{
    out << "%FLAG BOND_EQUIL_VALUE" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_bond_types_; i++)
    {
        TopologyFileSpace::TopologyBondType* bond_type = this->GetBondTypeByIndex(i);
        if(bond_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << bond_type->GetEquilibriumValue();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}


void TopologyFile::ResolveAngleForceConstantSection(std::ofstream& out)
{

    out << "%FLAG ANGLE_FORCE_CONSTANT" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_angle_types_; i++)
    {
        TopologyFileSpace::TopologyAngleType* angle_type = this->GetAngleTypeByIndex(i);
        if(angle_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << angle_type->GetForceConstant();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveAngleEquilValueSection(std::ofstream& out)
{
    out << "%FLAG ANGLE_EQUIL_VALUE" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_angle_types_; i++)
    {
        TopologyFileSpace::TopologyAngleType* angle_type = this->GetAngleTypeByIndex(i);
        if(angle_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << angle_type->GetEquilibriumValue();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveDihedralForceConstantSection(std::ofstream& out)
{
    out << "%FLAG DIHEDRAL_FORCE_CONSTANT" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_dihedral_types_; i++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = this->GetDihedralTypeByIndex(i);
        if(dihedral_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << dihedral_type->GetForceConstant();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveDihedralPeriodicitySection(std::ofstream& out)
{
    out << "%FLAG DIHEDRAL_PERIODICITY" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_dihedral_types_; i++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = this->GetDihedralTypeByIndex(i);
        if(dihedral_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << dihedral_type->GetPeriodicity();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveDihedralPhaseSection(std::ofstream& out)
{
    out << "%FLAG DIHEDRAL_PHASE" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_dihedral_types_; i++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = this->GetDihedralTypeByIndex(i);
        if(dihedral_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << dihedral_type->GetPhase();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveSceeScaleFactorSection(std::ofstream& out)
{
    out << "%FLAG SCEE_SCALE_FACTOR" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_dihedral_types_; i++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = this->GetDihedralTypeByIndex(i);
        if(dihedral_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << dihedral_type->GetScee();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count ++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveScnbScaleFactorSection(std::ofstream& out)
{
    out << "%FLAG SCNB_SCALE_FACTOR" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_dihedral_types_; i++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = this->GetDihedralTypeByIndex(i);
        if(dihedral_type != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << dihedral_type->GetScnb();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveSoltySection(std::ofstream& out)
{
    out << "%FLAG SOLTY" << std::endl
        << "%FORMAT(5E16.8)" << std::endl << std::endl;
    //
}

void TopologyFile::ResolveLennardJonesACoefSection(std::ofstream& out)
{
    out << "%FLAG LENNARD_JONES_ACOEF" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(unsigned int i = 0; i < pairs_.size(); i++)
    {
        TopologyFileSpace::TopologyAtomPair* atom_pair = this->GetAtomPairByIndex(i+1);
        if(atom_pair != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << atom_pair->GetCoefficientA();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }

    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveLennardJonesBCoefSection(std::ofstream& out)
{
    out << "%FLAG LENNARD_JONES_BCOEF" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(unsigned int i = 0; i < pairs_.size(); i++)
    {
        TopologyFileSpace::TopologyAtomPair* atom_pair = this->GetAtomPairByIndex(i+1);
        if(atom_pair != NULL)
        {
            std::stringstream ss;
            ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << atom_pair->GetCoefficientB();
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }

    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveBondsIncHydrogenSection(std::ofstream& out)
{
    out << "%FLAG BONDS_INC_HYDROGEN" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(TopologyBondMap::iterator it = bonds_.begin(); it != bonds_.end(); it++)
    {
        TopologyBond* bond = (*it).second;
        std::vector<std::string> atom_names = bond->GetBonds();
        std::vector<std::string> residue_names = bond->GetResidueNames();
        if(bond->GetIncludingHydrogen())
        {
            int atom_index_1 = gmml::ConvertString<int>(gmml::Split(atom_names.at(0), "()").at(1));// +
                    //this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(0), gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)));
            int atom_index_2 = gmml::ConvertString<int>(gmml::Split(atom_names.at(1), "()").at(1));// +
                    //this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(1), gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)));
            int bond_type_index = bond->GetBondType()->GetIndex();
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_1-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_2-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << bond_type_index+1;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveBondsWithoutHydrogenSection(std::ofstream& out)
{
    out << "%FLAG BONDS_WITHOUT_HYDROGEN" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(TopologyBondMap::iterator it = bonds_.begin(); it != bonds_.end(); it++)
    {
        TopologyBond* bond = (*it).second;
        std::vector<std::string> atom_names = bond->GetBonds();
        std::vector<std::string> residue_names = bond->GetResidueNames();
        if(!bond->GetIncludingHydrogen())
        {
            int atom_index_1 = gmml::ConvertString<int>(gmml::Split(atom_names.at(0), "()").at(1)) ;//+
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(0), gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)));
            int atom_index_2 = gmml::ConvertString<int>(gmml::Split(atom_names.at(1), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(1), gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)));
            int bond_type_index = bond->GetBondType()->GetIndex();
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_1-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_2-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << bond_type_index+1;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveAnglesIncHydrogenSection(std::ofstream& out)
{
    out << "%FLAG ANGLES_INC_HYDROGEN" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(TopologyAngleMap::iterator it = angles_.begin(); it != angles_.end(); it++)
    {
        TopologyAngle* angle = (*it).second;
        std::vector<std::string> atom_names = angle->GetAngles();
        std::vector<std::string> residue_names = angle->GetResidueNames();
        if(angle->GetIncludingHydrogen())
        {
            int atom_index_1 = gmml::ConvertString<int>(gmml::Split(atom_names.at(0), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(0), gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)));
            int atom_index_2 = gmml::ConvertString<int>(gmml::Split(atom_names.at(1), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(1), gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)));
            int atom_index_3 = gmml::ConvertString<int>(gmml::Split(atom_names.at(2), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(2), gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)));
            int angle_type_index = angle->GetAngleType()->GetIndex();
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_1-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_2-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_3-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << angle_type_index+1;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count ==0)
        out << std::endl;
}

void TopologyFile::ResolveAnglesWithoutHydrogenSection(std::ofstream& out)
{
    out << "%FLAG ANGLES_WITHOUT_HYDROGEN" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(TopologyAngleMap::iterator it = angles_.begin(); it != angles_.end(); it++)
    {
        TopologyAngle* angle = (*it).second;
        std::vector<std::string> atom_names = angle->GetAngles();
        std::vector<std::string> residue_names = angle->GetResidueNames();
        if(!angle->GetIncludingHydrogen())
        {
            int atom_index_1 = gmml::ConvertString<int>(gmml::Split(atom_names.at(0), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(0), gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)));
            int atom_index_2 = gmml::ConvertString<int>(gmml::Split(atom_names.at(1), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(1), gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)));
            int atom_index_3 = gmml::ConvertString<int>(gmml::Split(atom_names.at(2), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(2), gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)));
            int angle_type_index = angle->GetAngleType()->GetIndex();
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_1-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_2-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_3-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << angle_type_index+1;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveDihedralsIncHydrogenSection(std::ofstream& out)
{
    out << "%FLAG DIHEDRALS_INC_HYDROGEN" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(TopologyDihedralMap::iterator it = dihedrals_.begin(); it != dihedrals_.end(); it++)
    {
        TopologyDihedral* dihedral = (*it).second;
        std::vector<std::string> atom_names = dihedral->GetDihedrals();
        std::vector<std::string> residue_names = dihedral->GetResidueNames();
        if(dihedral->GetIncludingHydrogen())
        {
            int atom_index_1 = gmml::ConvertString<int>(gmml::Split(atom_names.at(0), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(0), gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)));
            int atom_index_2 = gmml::ConvertString<int>(gmml::Split(atom_names.at(1), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(1), gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)));
            int atom_index_3 = gmml::ConvertString<int>(gmml::Split(atom_names.at(2), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(2), gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)));
            int atom_index_4 = gmml::ConvertString<int>(gmml::Split(atom_names.at(3), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(3), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(3), gmml::ConvertString<int>(gmml::Split(residue_names.at(3), "()").at(1)));
            int dihedral_type_index = dihedral->GetDihedralType()->GetIndex();
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_1-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_2-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            if(dihedral->GetIgnoredGroupInteraction())
                out << std::setw(ITEM_LENGTH) << std::right << -(atom_index_3-1)*3;
            else
                out << std::setw(ITEM_LENGTH) << std::right << (atom_index_3-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            if(dihedral->GetIsImproper())
                out << std::setw(ITEM_LENGTH) << std::right << -(atom_index_4-1)*3;
            else
                out << std::setw(ITEM_LENGTH) << std::right << (atom_index_4-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << dihedral_type_index+1;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveDihedralsWithoutHydrogenSection(std::ofstream& out)
{
    out << "%FLAG DIHEDRALS_WITHOUT_HYDROGEN" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(TopologyDihedralMap::iterator it = dihedrals_.begin(); it != dihedrals_.end(); it++)
    {
        TopologyDihedral* dihedral = (*it).second;
        std::vector<std::string> atom_names = dihedral->GetDihedrals();
        std::vector<std::string> residue_names = dihedral->GetResidueNames();
        if(!dihedral->GetIncludingHydrogen())
        {
            int atom_index_1 = gmml::ConvertString<int>(gmml::Split(atom_names.at(0), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(0), gmml::ConvertString<int>(gmml::Split(residue_names.at(0), "()").at(1)));
            int atom_index_2 = gmml::ConvertString<int>(gmml::Split(atom_names.at(1), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(1), gmml::ConvertString<int>(gmml::Split(residue_names.at(1), "()").at(1)));
            int atom_index_3 = gmml::ConvertString<int>(gmml::Split(atom_names.at(2), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(2), gmml::ConvertString<int>(gmml::Split(residue_names.at(2), "()").at(1)));
            int atom_index_4 = gmml::ConvertString<int>(gmml::Split(atom_names.at(3), "()").at(1));// +
//                    this->assembly_->GetResidueByIndex(gmml::ConvertString<int>(gmml::Split(residue_names.at(3), "()").at(1)))->GetStartingAtomIndex() - 1;
            //this->assembly_->GetAtomIndexByName(atom_names.at(3), gmml::ConvertString<int>(gmml::Split(residue_names.at(3), "()").at(1)));
            int dihedral_type_index = dihedral->GetDihedralType()->GetIndex();
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_1-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << (atom_index_2-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            if(dihedral->GetIgnoredGroupInteraction())
                out << std::setw(ITEM_LENGTH) << std::right << -(atom_index_3-1)*3;
            else
                out << std::setw(ITEM_LENGTH) << std::right << (atom_index_3-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            if(dihedral->GetIsImproper())
                out << std::setw(ITEM_LENGTH) << std::right << -(atom_index_4-1)*3;
            else
                out << std::setw(ITEM_LENGTH) << std::right << (atom_index_4-1)*3;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
            out << std::setw(ITEM_LENGTH) << std::right << dihedral_type_index+1;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveExcludedAtomsListSection(std::ofstream& out)
{
    out << "%FLAG EXCLUDED_ATOMS_LIST" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            std::vector<std::string> excluded_atoms = atom->GetExcludedAtoms();
            if(excluded_atoms.size() == 0)
            {
                out << std::setw(ITEM_LENGTH) << std::right << 0;
                count++;
                total_count++;
                if(count == MAX_IN_LINE)
                {
                    count = 0;
                    out << std::endl;
                }
            }
            for(std::vector<std::string>::iterator it = excluded_atoms.begin(); it != excluded_atoms.end(); it++)
            {
                std::string atom_id = (*it);
                int index1 = gmml::ConvertString<int>(gmml::Split(atom_id, "()").at(3));
                out << std::setw(ITEM_LENGTH) << std::right << index1;
                count++;
                total_count++;
                if(count == MAX_IN_LINE)
                {
                    count = 0;
                    out << std::endl;
                }
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveHydrogenBondACoefSection(std::ofstream& out)
{
    out << "%FLAG HBOND_ACOEF" << std::endl
        << "%FORMAT(5E16.8)" << std::endl << std::endl;
    //
}

void TopologyFile::ResolveHydrogenBondBCoefSection(std::ofstream& out)
{
    out << "%FLAG HBOND_BCOEF" << std::endl
        << "%FORMAT(5E16.8)" << std::endl << std::endl;
    //
}

void TopologyFile::ResolveHBCutSection(std::ofstream& out)
{
    out << "%FLAG HBCUT" << std::endl
        << "%FORMAT(5E16.8)" << std::endl << std::endl;
    //
}

void TopologyFile::ResolveAmberAtomTypeSection(std::ofstream& out)
{
    out << "%FLAG AMBER_ATOM_TYPE" << std::endl
        << "%FORMAT(20a4)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 20;
    const int ITEM_LENGTH = 4;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            out << std::setw(ITEM_LENGTH) << std::left << atom->GetType();
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveTreeChainClassificationSection(std::ofstream& out)
{
    out << "%FLAG TREE_CHAIN_CLASSIFICATION" << std::endl
        << "%FORMAT(20a4)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 20;
    const int ITEM_LENGTH = 4;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            if(!atom->GetTreeChainClassification().empty())
                out << std::setw(ITEM_LENGTH) << std::left << atom->GetTreeChainClassification();
            else
                out << std::setw(ITEM_LENGTH) << std::left << "0";
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveJoinArraySection(std::ofstream& out)
{
    out << "%FLAG JOIN_ARRAY" << std::endl
        << "%FORMAT(10I8)" << std::endl;
    //
    //out << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            // TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            //if(atom->GetAtomicNumber() != gmml::iNotSet)
            //    out << std::setw(ITEM_LENGTH) << std::right << atom->GetAtomicNumber();
            //else
            out << std::setw(ITEM_LENGTH) << std::right << 0;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;

}

void TopologyFile::ResolveIRotatSection(std::ofstream& out)
{
    out << "%FLAG IROTAT" << std::endl
        << "%FORMAT(10I8)" << std::endl ;
    //out << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 10;
    const int ITEM_LENGTH = 8;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            // TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            //if(atom->GetAtomicNumber() != gmml::iNotSet)
            //out << std::setw(ITEM_LENGTH) << std::right << atom->GetAtomicNumber();
            //else
            out << std::setw(ITEM_LENGTH) << std::right << 0;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;

}

void TopologyFile::ResolveRadiusSetSection(std::ofstream& out)
{
    if(radius_set_.size() != 0)
    {
        std::string radius_set = radius_set_.at(0);
        std::replace(radius_set.begin(), radius_set.end(), '#', ' ');
        out << "%FLAG RADIUS_SET" << std::endl
            << "%FORMAT(1a80)" << std::endl
            << radius_set << std::endl;
    }
    else
    {
        out << "%FLAG RADIUS_SET" << std::endl
            << "%FORMAT(1a80)" << std::endl << std::endl;
    }

}

void TopologyFile::ResolveRadiiSection(std::ofstream& out)
{
    out << "%FLAG RADII" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);
        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            std::stringstream ss;
            if(atom->GetRadii() != gmml::dNotSet)
                ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << atom->GetRadii();
            else
                ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << 0.0;
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

void TopologyFile::ResolveSolventPointersSection(std::ofstream& out)
{
    out << "%FLAG SOLVENT_POINTERS" << std::endl
        << "%FORMAT(3I8)" << std::endl;
    int total_count = 0;
    int count = 0;
    const int MAX_IN_LINE = 3;
    // const int ITEM_LENGTH = 8;

    int final_residue=0;
    for(int i = 0; i < number_of_residues_; i++)
       {
           TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);

           if(residue->GetIsResidueSolvent()==false)
           { //std::cout<<"is residue solvent in topology file"<<std::endl;
            //std::cout<<"residue name"<<residue->GetResidueName()<<std::endl;
               final_residue++;
           }

           count++;
           total_count++;
           if(count == MAX_IN_LINE)
           {
               count = 0;
               out << std::endl;
           }
       }
        out<<final_residue;

       if(count < MAX_IN_LINE && count != 0)
           out << std::endl;
       if(total_count == 0)
           out << std::endl;
   }

void TopologyFile::ResolveScreenSection(std::ofstream& out)
{
    out << "%FLAG SCREEN" << std::endl
        << "%FORMAT(5E16.8)" << std::endl;
    int total_count = 0;
    int count = 0;
    int index = 0;
    const int MAX_IN_LINE = 5;
    const int ITEM_LENGTH = 16;
    for(int i = 0; i < number_of_residues_; i++)
    {
        TopologyResidue* residue = this->assembly_->GetResidueByIndex(i+1);

        for(unsigned int j = 0; j < residue->GetAtoms().size(); j++)
        {
            TopologyAtom* atom = residue->GetAtomByIndex(index+1);
            index++;
            std::stringstream ss;
            if(atom->GetScreen() != gmml::dNotSet)
                ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << atom->GetScreen();
            else
                ss << std::setw(ITEM_LENGTH) << std::right << std::scientific << std::setprecision(8) << 0.0;
            std::string sss = ss.str();
            std::transform(sss.begin(), sss.end(), sss.begin(), ::toupper);
            out << sss;
            count++;
            total_count++;
            if(count == MAX_IN_LINE)
            {
                count = 0;
                out << std::endl;
            }
        }
    }
    if(count < MAX_IN_LINE && count != 0)
        out << std::endl;
    if(total_count == 0)
        out << std::endl;
}

//////////////////////////////////////////////////////////
//                      DISPLAY FUNCTION                //
//////////////////////////////////////////////////////////
void TopologyFile::Print(std::ostream &out)
{
    out << "============================ " << title_ << " ===========================" << std::endl;
    assembly_->Print(out);
    out << "------------------------------ Atom Pairs ------------------------------" << std::endl;
    for(TopologyAtomPairMap::iterator it = pairs_.begin(); it != pairs_.end(); it++)
    {
        TopologyFileSpace::TopologyAtomPair* atom_pair = (*it).second;
        atom_pair->Print(out);
    }
    out << "------------------------------ Bond Types ------------------------------" << std::endl;
    for(TopologyBondTypeMap::iterator it = bond_types_.begin(); it != bond_types_.end(); it++)
    {
        TopologyFileSpace::TopologyBondType* bond_type = (*it).second;
        bond_type->Print(out);
        out << std::endl;
    }
    out << "------------------------------ Angle Types ------------------------------" << std::endl;
    for(TopologyAngleTypeMap::iterator it = angle_types_.begin(); it != angle_types_.end(); it++)
    {
        TopologyAngleType* angle_type = (*it).second;
        angle_type->Print(out);
        out << std::endl;
    }
    out << "------------------------------ Dihedral Types ------------------------------" << std::endl;
    for(TopologyDihedralTypeMap::iterator it = dihedral_types_.begin(); it != dihedral_types_.end(); it++)
    {
        TopologyFileSpace::TopologyDihedralType* dihedral_type = (*it).second;
        dihedral_type->Print(out);
        out << std::endl;
    }
    out << "------------------------------ Bonds ------------------------------" << std::endl;
    for(TopologyBondMap::iterator it = bonds_.begin(); it != bonds_.end(); it++)
    {
        TopologyBond* bond = (*it).second;
        bond->Print(out);
    }
    out << "------------------------------ Angles ------------------------------" << std::endl;
    for(TopologyAngleMap::iterator it = angles_.begin(); it != angles_.end(); it++)
    {
        TopologyAngle* angle = (*it).second;
        angle->Print(out);
    }
    out << "------------------------------ Dihedrals ------------------------------" << std::endl;
    for(TopologyDihedralMap::iterator it = dihedrals_.begin(); it != dihedrals_.end(); it++)
    {
        TopologyDihedral* dihedral = (*it).second;
        dihedral->Print(out);
    }

}
